\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{graphicx}

\usepackage{bm}
\usepackage{mathtools}

\DeclareMathOperator{\clipop}{clip}
\DeclareMathOperator{\sgnop}{sgn}
\DeclareMathOperator{\concat}{concat}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\edt}{\tau_{\bm{e}}}
\newcommand{\de}{\bm{\Delta e}}

\usepackage{booktabs}
\usepackage{longtable}
\newcommand{\sprule}{\rule{0pt}{1.3em}}

\usepackage{float}

\newcommand{\fig}[3][1]{
    \begin{figure}[H]
        \centering
        \includegraphics[width=#1\textwidth]{figs/#2}
        \caption{#3}\label{#2}
    \end{figure}
}

\usepackage[newfloat, cache=false]{minted}
\usepackage{algpseudocode}

\usepackage[singlelinecheck=false]{caption}

\DeclareCaptionLabelSeparator{labelsep}{~---~}
\captionsetup{labelsep=labelsep}

\DeclareCaptionLabelFormat{listlbl}{Листинг #2}
\captionsetup[listing]{
    justification=raggedright, labelformat=listlbl, position=top}
\DeclareCaptionLabelFormat{figlbl}{Рисунок #2}
\captionsetup[figure]{
    justification=centering, labelformat=figlbl, position=bottom}


\begin{document}

\section{Верификация устойчивости времени доставки по отношению к эмбеддингам
узлов для всей сети}

\subsection{Анализ графа сети}

Для того, чтобы исследовать влияние небольших изменений эмбеддингов на время
доставки во всей конвейерной сети, мы можем запустить описанный ранее алгоритм
верификации для каждой пары узлов графа сети~\cite{edt-bound-verif}. Так как
контроллер учитывает информацию не только о соседних узлах, но и о конечном
узле, такие пары являются упорядоченными, а их количество равняется числу
размещений $A_n^2 = n(n-1)$, где $n$ --- порядок графа.

Мы считаем, что отклонители хорошо обучены, а сумка обычно движется по
кратчайшему пути. Так как мы имеем ограничение на изменение эмбеддингов,
их изменение на кратчайшем пути будет в большей степени отражаться на времени
доставки. Рассмотрим пример графа сети, представленный на
рисунке~\ref{example-graph}.

\fig[.3]{example-graph}{Пример графа конвейерной сети}

Задача расчета ожидаемого времени доставки параметризуется множеством
нетривиальных отклонителей, лежащих на возможных путях сумки, а также конечным
узлом. Для доставки из узла $o_1$ в узел $j_2$ мы можем формализовать ее
следующим образом:
\[
    \{d_1, d_3\}_{j_2} \to t_{o_1 \to j_2}.
\]
Теперь рассмотрим задачу между парой, кратчайший путь которой является
суффиксом исходного кратчайшего пути:
\[
    \{d_3\}_{j_2} \to t_{d_1 \to j_2}.
\]
Можно обратить внимание на то, что она является подзадачей исходной, а все
связанные эмбеддинги могли быть уже исследованы в более полной задаче. Поэтому
чтобы минимизировать количество запусков верификации, мы будем искать пару,
имеющую самый длинный кратчайший путь, который не является суффиксом у ранее
рассмотренных пар.

Также нам стоит учесть случаи, когда кратчайший путь между парой не является
суффиксом, но задача расчета ожидаемого времени доставки в точности
повторяется. Например, это можно наблюдать у пар $(o_1, j_2)$ и $(o_2, j_2)$.

Заметим, что не все пары вершин могут иметь нетривиальные отклонители на своем
кратчайшем пути. Такие пары мы также можем не рассматривать, так как эмбеддинги
узлов никак не влияют на время доставки.

\subsection{Описание алгоритма}

Псевдокод алгоритма минимизации количества пар для верификации приведен
листинге~\ref{GetPairs}.

\begin{listing}[H]
\caption{Поиск множества пар}\label{GetPairs}
\begin{algorithmic}[1]
\Function{GetPairs}{$g$}
    \State $V \gets \text{GetNodes}(g)$
    \State \Comment пара состоит из начала и конца кратчайшего пути
    \For{$(o, i) \in V^2$} 
        \State $\text{path} \gets \text{FindShortestPath}(g, o, i)$
        \If{$\exists \text{path} \land d \in \text{path}$}
            \State paths $\gets$ path
        \EndIf
    \EndFor
    \State
    \State Sort(paths) \Comment по возрастанию кол-ва узлов
    \While{$\text{paths} \neq \emptyset$}
        \State path $\gets$ Pop(paths)
        \State RemoveSuffixes(path, paths)
        \State $(o, i) \gets \text{path}$
        \If{$\text{GetDiverters}(o, i)
            \not\in \text{GetDiverters}(\text{res}, i)$}
        \State $\text{pairs} \gets (o, i)$
        \EndIf
    \EndWhile
    \State
    \State \Return pairs
\EndFunction
\end{algorithmic}
\end{listing}

\begin{enumerate}
    \item Для каждой пары узлов графа конвейерной сети находим кратчайший
        путь~(5). Если этот путь существует и содержит хотя бы один
        отклонитель, то сохраняем его~(6--7).

    \item Извлекаем самый длинный путь и удаляем все его суффиксы из множества
        найденных путей~(10--13). Если множество отклонителей данной пары не
        совпадает с каким-либо множеством отклонителей сохраненых пар, которые
        имеют тот же сток, то сохраняем эту пару~(16--17).
\end{enumerate}

Псевдокод алгоритма верификации устойчивости времени доставки для всей сети
приведен в листинге~\ref{VerifEdtRobustnessWrtEmb}

\begin{listing}[H]
\caption{Верификация устойчивости времени доставки для всей сети}
\label{VerifEdtRobustnessWrtEmb}
\begin{algorithmic}[1]
\Procedure{VerifEdtRobustnessWrtEmb}{$g$}
    \For{$(o, i) \in \text{GetPairs}(g)$}
        \State \Comment конечный узел не должен иметь исходящих ребер
        \State $m \gets \text{CreateAbsorbingMC}(g, i)$
        \State $\tau \gets \text{CreateEDTSolver}(m, o)$
        \If{GetNontrivDvtrs($\tau$) $= \emptyset$}
            \State \textbf{continue}
        \EndIf
        \State
        \State $t_{\top} \gets \tau()$
        \For{$k \in (0.95, 0.99, 1.01, 1.05)$}
            \State $t_b \gets t_{\top} \cdot k$
            \State VerifEdtBoundWrtEmb($t_b$)
        \EndFor
    \EndFor
\EndProcedure
\end{algorithmic}
\end{listing}

\begin{enumerate}
    \item Для каждой необходимой пары по полному графу сети создаем поглощающую
        марковскую цепь с одним поглощающим состоянием (2--4).
    \item Определяем функцию расчета ожидаемого времени доставки при помощи
        марковской цепи (5). Если нетривиальные отклонители отсутствуют, то
        отбрасываем текущую пару (6--7).
    \item Рассчитываем ожидаемое время доставки и используем его в качестве
        границы для верификации (10--13).
\end{enumerate}

\subsection{Результаты выполнения}

Результаты выполнения алгоритма для $\epsilon = 0.1$ и первого примера
конвейерной сети приведены в таблице~\ref{res1}.

\begin{longtable}{rrrcr}
\caption{Результаты верификации устойчивости времени доставки для всей сети}
\label{res1}\\
    \toprule
    & $t_{\top}$ & $t_b$ & Вериф. & Прод., \\
    &         &       &        & c \\
    \midrule
    $o_1 \to d_7$ & 40.10 & 38.10 & $-$ & 0.09 \\
              &       & 39.70 & $-$ & 0.19 \\
              &       & 40.50 & $+$ & 0.78 \\
              &       & 42.11 & $+$ & 0.52 \\
    \sprule
    $o_1 \to d_8$ & 50.10 & 47.60 & $-$ & 0.09 \\
              &       & 49.60 & $-$ & 0.11 \\
              &       & 50.60 & $+$ & 0.74 \\
              &       & 52.61 & $+$ & 0.34 \\
    \newpage
    \sprule
    $o_1 \to i_0$ & 50.15 & 47.64 & $-$ & 0.09 \\
              &       & 49.65 & $-$ & 0.11 \\
              &       & 50.65 & $+$ & 0.77 \\
              &       & 52.66 & $+$ & 0.53 \\
    \sprule
    $o_0 \to i_0$ & 40.20 & 38.19 & $-$ & 0.10 \\
              &       & 39.80 & $-$ & 0.12 \\
              &       & 40.60 & $+$ & 0.94 \\
              &       & 42.21 & $+$ & 0.66 \\ 
    \sprule
    $o_0 \to i_1$ & 53.10 & 50.45 & $-$ & 0.11 \\
              &       & 52.57 & $-$ & 0.11 \\
              &       & 53.63 & $+$ & 0.76 \\
              &       & 55.76 & $+$ & 0.41 \\
    \sprule
    $o_1 \to i_1$ & 43.25 & 41.09 & $-$ & 0.15 \\
              &       & 42.82 & $-$ & 0.17 \\
              &       & 43.68 & $+$ & 2.85 \\
              &       & 45.41 & $+$ & 1.80 \\
    \sprule
    $o_1 \to i_2$ & 53.06 & 50.41 & $-$ & 0.12 \\
              &       & 52.53 & $-$ & 0.16 \\
              &       & 53.59 & $+$ & 4.54 \\
              &       & 55.71 & $+$ & 1.64 \\
    \sprule
    $o_0 \to i_2$ & 53.07 & 50.42 & $-$ & 0.09 \\
              &       & 52.54 & $-$ & 0.11 \\
              &       & 53.60 & $+$ & 0.63 \\
              &       & 55.72 & $+$ & 0.28 \\
    \sprule
    $o_1 \to i_3$ & 43.10 & 40.95 & $-$ & 0.14 \\
              &       & 42.67 & $-$ & 0.17 \\
              &       & 43.53 & $+$ & 2.27 \\
              &       & 45.26 & $+$ & 1.45 \\
    \sprule
    $o_0 \to i_3$ & 43.15 & 40.99 & $-$ & 0.10 \\
              &       & 42.72 & $-$ & 0.11 \\
              &       & 43.58 & $+$ & 0.91 \\
              &       & 45.31 & $+$ & 0.54 \\
    \sprule
    $d_3 \to i_3$ & 43.10 & 40.95 & $-$ & 0.10 \\
              &       & 42.67 & $-$ & 0.12 \\
              &       & 43.53 & $+$ & 0.82 \\
              &       & 45.26 & $+$ & 0.56 \\
    \sprule
    $o_1 \to j_0$ & 30.10 & 28.60 & $-$ & 0.09 \\
              &       & 29.80 & $-$ & 0.11 \\
              &       & 30.40 & $+$ & 0.89 \\
              &       & 31.61 & $+$ & 0.52 \\
    \bottomrule
\end{longtable}

\section{Поиск состязательного примера}

\subsection{Формализация задачи}

Требуется найти изменение с заданным ограничением в эмбеддингах, при котором
ожидаемое время доставки будет максимальным:
\[
    \argmax_{\Vert \de \Vert_{\infty} \leq \epsilon}{\edt(\de)},
\]
где $\bm{e}$ --- конкатенация эмбеддингов узлов, участвующих в расчете
Q-значения.\\

Найденное худшее время доставки является оценкой нижней грани множества
значений, которые могут быть верифицированы. Приведенный алгоритм использует
итеративный метод быстрого знака градиента~\cite{iter-fast-grad-sign}.

\subsection{Описание алгоритма}

В листинге~\ref{Perturb} приведен псевдокод алгоритма.

\begin{listing}[H]
\caption{Поиск оптимального возмущения эмбеддингов}\label{Perturb}
\begin{algorithmic}[1]
\Function{Perturb}{$\bm{e}, \alpha$}
    \For{$i \in I$}
        \If{$i \neq I[-1]$}
        \State $\de^{(0)} \gets \text{direc} \in U_m(-\epsilon, \epsilon)
               \cdot \text{scale} \in U(0, 1)$
        \Else
            \State $\de^{(0)} \gets 0^m$
        \EndIf
        \State
        \For{$j \in J$}
            \State grad = $\nabla \edt(\de)$
            \State
            \If{$\Vert \text{grad} \Vert_1 = 0$}
                \State \textbf{break}
            \EndIf
            \State
            \State $\text{step} = \sgnop \text{grad} \cdot \epsilon \cdot \alpha$
            \State $\de^{(j)} = \de^{(j-1)} + \text{step}$
            \State
            \If{$\Vert \de^{(j)} \Vert_{\infty} > \epsilon$}
                \State $\de^{(j)} \gets \{v : v = \clipop_\epsilon \Delta e_i\}$
            \EndIf
        \EndFor
        \State
        \State $t \gets \edt{(\de)}$
        \If{$t > t_b$}
            \State $t_b \gets t$
            \State $\de_b \gets \de$
        \EndIf
    \EndFor
    \State
    \State \Return $\de_b$
\EndFunction
\end{algorithmic}
\end{listing}

\begin{enumerate}
    \item Выполняем несколько итераций поиска возмущения (2). В начале каждой
        итерации определяем случайный начальный вектор возмущения из
        равномерного распределения, но применяем эвристику и на последней
        итерации оставляем вектор нулевым (3--6). Если мы просто возьмем
        вектор из совместного распределения, то при его большой размерности
        норма будет близка к своей границе: $\lim_{|\bm{e}| \to \infty} \Vert
        \bm{e} \Vert_{\infty} = \epsilon$. Чтобы это избежать, умножим вектор
        на случайный масштабный коэффициент.

    \item Используем несколько шагов проективного градиентного спуска для
        улучшения начального возмущения (9). Отметим, что для удобства мы можем
        определить градиент следующим образом: $\nabla_{\de}\tau(\bm{e} + \de)
        = \nabla \tau(\bm{e} + \de) \cdot 1$ (10). Если градиент
        получился нулевым, то прекращаем спуск (12--13).

    \item Преобразовываем градиент, вычисляя его знак и масштабируя (16). Здесь
        $\alpha$ является подбираемым параметром, определяющим скорость
        спуска.

    \item Прибавляем преобразованный градиент к аргументу целевой функции (17).
        Мы прибавляем градиент, так как наша задача максимизировать время
        доставки.

    \item Проверяем ограничение на норму вектора (19). Если оно нарушено, то
        выполняем проекцию вектора на границу нормы (20). Схематично эта
        операция изображена на рисунке~\ref{clip}. 

        \fig[.6]{clip}{Пример проекции вектора}

        Ее можно определить при помощи функции, которая выполняет коррекцию
        каждой компоненты:
        \[
             \clipop_\epsilon x =
             \begin{cases*}
                 \phantom{-}\epsilon  & if $x > \epsilon$ \\
                          -\epsilon   & if $x < -\epsilon$ \\
                 \phantom{-}x  & else
             \end{cases}.
        \]

    \item После выполнения спуска мы сохраняем полученное возмущение, если оно
        дает наибольшее время доставки (24--27).
\end{enumerate}

\subsection{Результаты выполнения}

Данные в таблице~\ref{res2} описывают процесс выполнения последнего
градиентного спуска для пары вершин $(o_1, i_3)$ при $\epsilon = 0.4$, $\alpha
= 0.02$.

\begin{table}[H]
\caption{Результаты градиентного спуска}\label{res2}
\centering
\begin{tabular}{rrrrrr}
    \toprule
    Шаг &
    $t_{\top}$ &
    $\Vert \de \Vert_{\infty}$ &
    $\Vert \bm{e} + \de \Vert_{\infty}$ &
    $p_2$ & $p_3$ \\
    \midrule
    1   & 43.100559 & 0.08590 & 5.20921 & 0.0050 & 0.9950 \\
    5   & 43.100675 & 0.12055 & 5.16921 & 0.0050 & 0.9950 \\
    10  & 43.101031 & 0.16055 & 5.12921 & 0.0050 & 0.9950 \\
    15  & 43.102261 & 0.20055 & 5.08921 & 0.0051 & 0.9950 \\
    20  & 43.106360 & 0.24055 & 5.04921 & 0.0053 & 0.9950 \\
    25  & 43.120090 & 0.28055 & 5.00921 & 0.0060 & 0.9950 \\
    30  & 43.168993 & 0.32055 & 5.00570 & 0.0084 & 0.9950 \\
    35  & 43.349849 & 0.36055 & 5.04570 & 0.0174 & 0.9949 \\
    40  & 44.038848 & 0.40000 & 5.08570 & 0.0517 & 0.9949 \\
    45  & 45.812226 & 0.40000 & 5.12570 & 0.1399 & 0.9948 \\
    50  & 48.289755 & 0.40000 & 5.16570 & 0.2631 & 0.9947 \\
    55  & 50.217126 & 0.40000 & 5.20570 & 0.3589 & 0.9946 \\
    60  & 50.849359 & 0.40000 & 5.22040 & 0.3904 & 0.9946 \\
    65  & 50.865898 & 0.40000 & 5.22040 & 0.3912 & 0.9946 \\
    70  & 50.882441 & 0.40000 & 5.22040 & 0.3920 & 0.9946 \\
    75  & 50.898993 & 0.40000 & 5.22040 & 0.3928 & 0.9946 \\
    80  & 50.915559 & 0.40000 & 5.22040 & 0.3936 & 0.9946 \\
    85  & 50.932139 & 0.40000 & 5.22040 & 0.3945 & 0.9946 \\
    90  & 50.948734 & 0.40000 & 5.22040 & 0.3953 & 0.9945 \\
    95  & 50.957471 & 0.40000 & 5.22040 & 0.3957 & 0.9945 \\
    100 & 50.963990 & 0.40000 & 5.22040 & 0.3960 & 0.9945 \\
    \bottomrule
\end{tabular}
\end{table}

Можно заметить, что алгоритм стремится изменять эмбеддинги таким образом, чтобы
отклонитель $d_2$ (соответствует вероятность $p_2$), лежащий на кратчайшем
пути, стал чаще принимать неверные решения.

\section{Верификация устойчивости времени доставки в динамической сети}

Допустим, что нагрузка на конвейер не постоянна, а меняется в течение времени.
Тогда вес ребра в графе сети будем определять не константой, а некоторым
распределением. Для того, чтобы выполнить верификацию, возьмем момент времени,
когда нагрузка на сеть максимальна. Преобразование графа сети выполним, как
показано на рисунке~\ref{dyn-gr}.

\fig[.4]{dyn-gr}{Преобразование динамического графа}

\begin{listing}[H]
\caption{Верификация в динамическом графе}\label{VerifDynNetwork}
\begin{algorithmic}[1]
\Function{VerifDynNetwork}{$\bm{e}$}
    \State $E \gets \text{GetEdges}(g)$
    \For{edge $\in E$}
        \State $w \gets$ GetWeight(edge)
        \State $c \in X$ \Comment $X$ имеет распределение Парето
        \State SetWeight(edge, $w \cdot c$)
    \EndFor
    \State
    \State Relearn($\bm{e}$)
    \State
    \State \Return VerifEdtBoundWrtEmb()
\EndFunction
\end{algorithmic}
\end{listing}

\begin{enumerate}
    \item Вес каждого ребра графа сети доможнаем на случайное число из
        распределения Парето (2--6).

    \item Переобучаем эмбеддинги узлов на новой топологии графа (9).

    \item Выполняем верификацию границы времени доставки (11).
\end{enumerate}

\begin{table}[H]
\caption{Результаты верификации границы времени доставки в динамической сети}
\label{res2}
\centering
\begin{tabular}{rrrrrr}
    \\
    \toprule
    $\epsilon$ &
    $t_b = 44.00$ &
    $t_b = 43.50$ &
    $t_b = 43.12$ &
    $t_b = 43.10$ &
    $t_b = 43.00$ \\
    \midrule
    0.00 & + () & + () & + () & + () & + () \\
    0.01 & + () & + () & + () & + () & + () \\
    0.10 & + () & + () & + () & + () & + () \\
    0.20 & + () & + () & + () & + () & + () \\
    0.40 & + () & + () & + () & + () & + () \\
    0.80 & + () & + () & + () & + () & + () \\
    \bottomrule
\end{tabular}
\end{table}

\begin{thebibliography}{3}
    \bibitem{edt-bound-verif}
        Мультиагентные алгоритмы маршрутизации на основе глубоких нейронных
        сетей с подкреплением и их верификация. --- Санкт-Петербург. --- 2020.
        --- 108 c.

    \bibitem{iter-fast-grad-sign}
        Alex Kurakin, Ian Goodfellow, and Samy Bengio. Adversarial examples in
        the physical world : technical report. // arXiv. --- 2016. --- URL:
        https://arxiv.org/abs/1607.02533
\end{thebibliography}






\end{document}
